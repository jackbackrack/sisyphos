; Generated by JITX 2.5.0
#use-added-syntax(jitx)
defpackage main :
  import core
  import math
  import geom/vec
  import jitx
  import jitx/commands
  import ocdb/utils/generic-components
  import helpers
  import components/led-ws2812b

pcb-material copper :
  type = Conductor
  name = "Copper"
  
pcb-material soldermask :
  type = Dielectric
  dielectric-coefficient = 3.9
  name = "Taiyo BSN4000"

pcb-material core :
  type = Dielectric
  dielectric-coefficient = 4.26
  name = "PR4 Core"

public pcb-stackup jlcpcb-2-layer-62-mil :
  name = "JLCPCB 2-layer 0.062in"
  layer(0.01778, soldermask) ; 7mil over conductor
  layer(0.03556, copper) ; 1.0oz/foot
  layer(1.46812, core)
  layer(0.03556, copper) ; 1.0oz/foot
  layer(0.01778, soldermask) ; 7mil over conductor

; Setup the board
defn setup-board (board-shape:Shape) :
;  set-board(ocdb/utils/defaults/default-board(ocdb/manufacturers/stackups/jlcpcb-jlc2313, board-shape))
  set-board(ocdb/utils/defaults/default-board(jlcpcb-2-layer-62-mil, board-shape))
  set-rules(ocdb/manufacturers/rules/jlcpcb-rules)

pcb-module unicord :
  pin GND
  pin VCC
  pin D
  inst header : pin-header(3)
  place(header) at loc(0.0, 0.0) on Top
  net (GND, header.p[1])
  net (VCC, header.p[3])
  net (D, header.p[2])
  val c = 2.54
  layer(Silkscreen("f-silk", Top)) = 
    Union $ [ Text("+", c, W, loc(1.5, -1.0 * c)), Text("-", c, W, loc(1.5, 1.0 * c)) ]

defn orientation (i:Int, j:Int) -> Double :
  0.0 when ((j % 2) == 1) else 180.0
defn zigzag (i-max:Int, j-max:Int) -> Seqable<V2i> :
  for j in 0 to j-max seq-cat :
    for i in 0 to i-max seq :
      val x = i when ((j % 2) == 0) else (i-max - i - 1)
      V2i(x, j)
defn rotate (v:V2i, num:Int) -> V2i :
  V2i(num - x(v) - 1, num - y(v) - 1)
defn index (v:V2i, num:Int) -> Int :
  y(v) * num + x(v)

; Define the shape/size of the board
; val board-shape = Rectangle(100.0, 100.0)
val edge-length = 100.0
val el = edge-length
val cut-length = 5.0
val ang = acos(1.0 / 3.0)
val slope = cos(ang) / sin(ang)
val shrink = sin(ang)
defn warp (p:Point) -> Point :
  Point(x(p) + y(p) * slope, y(p) * shrink)
val face-board-shape = Polygon $ map(warp, [
  Point(-0.5 * el, -0.5 * el + cut-length), Point(-0.5 * el + cut-length, -0.5 * el), Point( 0.5 * el, -0.5 * el), 
  Point( 0.5 * el,  0.5 * el - cut-length), Point( 0.5 * el - cut-length,  0.5 * el), Point(-0.5 * el,  0.5 * el)
;  Point(-0.5 * el, -0.5 * el), Point( 0.5 * el, -0.5 * el), 
;  Point( 0.5 * el,  0.5 * el), Point(-0.5 * el,  0.5 * el)
  ])

; defn sqr (x:Double) : x * x
; defn distance (p0:Point, p1:Point) -> Double :
;   sqrt(sqr(x(p1) - x(p0)) + sqr(y(p1) - y(p0)))
; for i in 0 to 4 do :
;   println(distance(points(board-shape)[i], points(board-shape)[(i + 1) % 4]))

val face-board-height = edge-length
val face-board-width = edge-length

pcb-module face-design :
  val num = 8
  inst leds : components/led-ws2812b/module[num * num]

  val x-step = face-board-width / to-double(num)
  val y-step = face-board-height / to-double(num)
  val x-base = -0.5 * face-board-width + 0.5 * x-step
  val y-base = -0.5 * face-board-height + 0.5 * y-step
 
  defn indices-to-point (i:Double, j:Double) -> Point :
    warp(Point(x-base + to-double(i) * x-step, y-base + to-double(j) * y-step))

  for j in 0 to num do :
    for i in 0 to num do :
      place(leds[j * num + i]) at loc(indices-to-point(to-double(i), to-double(j)), orientation(i, j)) on Top

  ; val order = to-tuple $ for j in 0 to num seq-cat : for i in 0 to num seq : V2i(i, j)
  val order = to-tuple $ zigzag(num, num)

  inst screw-holes : mounting-hole(1.5, 2.7, 2.7)[4]
  val [slo, shi] = [0.5, to-double(num) - 1.5]
  val spoz = [V2d(slo, slo), V2d(slo, shi), V2d(shi, shi), V2d(shi, slo)]
  val [clo, chi] = [-0.5, to-double(num) - 0.5]
  val cpoz = [V2d(clo, clo), V2d(clo, chi), V2d(chi, chi), V2d(chi, clo)]
  for (i in 0 to false, spos in spoz) do :
    place(screw-holes[i]) at loc(indices-to-point(x(spos), y(spos))) on Top
    println(indices-to-point(x(spos), y(spos)))
  for cpos in cpoz do :
    println(indices-to-point(x(cpos), y(cpos)))

  inst in-header : unicord
  inst out-header : unicord

  val in-pt = indices-to-point(1.5, 0.5)
  val out-pt = indices-to-point(1.5, to-double(num) - 1.5)
  place(in-header) at loc(in-pt, 90.0) on Bottom
  place(out-header) at loc(out-pt, 90.0) on Bottom
  layer(Silkscreen("b-silk", Bottom)) = Text("in",  2.0, W, loc(in-pt + Point(5.0, 0.0)))
  layer(Silkscreen("b-silk", Bottom)) = Text("out", 2.0, W, loc(out-pt + Point(5.0, 0.0)))

  for i in 0 to length(order) - 1 do :
    val p0 = leds[index(order[i + 0], num)]
    val p1 = leds[index(order[i + 1], num)]
    net (p0.DO, p1.DI)
  net (in-header.D, leds[index(order[0], num)].DI)
  net (out-header.D, leds[index(order[length(order) - 1], num)].DO)
  net GND (in-header.GND, out-header.GND)
  net VCC (in-header.VCC, out-header.VCC)
  for i in 0 to length(order) do :
    net GND (leds[i].GND)
    net VCC (leds[i].VCC)

  ; Write the board version on silkscreen
  inst version-label  : ocdb/artwork/board-text/version-silkscreen("Version 0.0")
  place(version-label) at loc(warp(Point(0.0, face-board-height / 2.0 - 1.0))) on Bottom
  geom(GND) :
    copper-pour(LayerIndex(0), isolate = 0.13, rank = 0) = face-board-shape 
  geom(VCC) :
    copper-pour(LayerIndex(1), isolate = 0.13, rank = 0) = face-board-shape 

defn export-a-design () :
 set-paper(ANSI-E)
 set-export-backend(`kicad)
 export-cad()

defn face-board () :
  ; Set the design name - a directory with this name will be generated under the "designs" directory
  set-current-design("face-design")
  
  ; Set the schematic sheet size
  set-paper(ANSI-A)
  
  ; Setup the board properties
  setup-board(face-board-shape)
  
  ; Set the top level module (the module to be compile into a schematic and PCB)
  set-main-module(face-design)
  
  ; View the results
  view-board()
  ; view-schematic()
  ; view-design-explorer()
  export-a-design()

face-board()
